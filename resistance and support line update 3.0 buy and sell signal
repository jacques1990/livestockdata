//@version=5
indicator("LIVE Wick B/S on S/R (Safe)", overlay=true, max_lines_count=500, max_boxes_count=500)

// ===== Inputs =====
windowMinutes     = input.int(10, "Update drawings window (minutes)", minval=2, maxval=240)
lookbackPivots    = input.int(800, "Pivot memory (signals)", minval=50, maxval=5000)
pivotStrength     = input.int(2, "Pivot Strength (1-2 best 1m/3m)", minval=1, maxval=15)
zonePercent       = input.float(0.30, "Zone Width %", minval=0.05, maxval=3.0)
extendRight       = input.int(120, "Extend right bars", minval=10, maxval=500)
maxDrawn          = input.int(120, "Max drawings kept", minval=20, maxval=400)

minWickPct        = input.float(0.45, "Min wick % of range", minval=0.10, maxval=0.95)
maxOppWickPct     = input.float(0.25, "Max opposite wick %", minval=0.05, maxval=0.90)
minRangeTicks     = input.int(3, "Min candle range (ticks)", minval=1, maxval=200)
returnBufferPct   = input.float(0.00, "Return buffer %", minval=0.0, maxval=0.50)

useEMAFilter      = input.bool(true, "EMA filter")
emaFastLen        = input.int(14, "EMA Fast", minval=2, maxval=200)
emaSlowLen        = input.int(20, "EMA Slow", minval=2, maxval=300)

resZoneColor      = input.color(color.new(color.red, 85), "Resistance Zone")
supZoneColor      = input.color(color.new(color.green, 85), "Support Zone")
resLineColor      = input.color(color.red, "Resistance Line")
supLineColor      = input.color(color.green, "Support Line")

// ===== Minutes -> bars =====
tfSec = timeframe.in_seconds(timeframe.period)
barsBackRaw = 10.0
if tfSec > 0
    barsBackRaw := math.ceil(windowMinutes * 60.0 / tfSec)
barsBack = int(math.max(barsBackRaw, 5))
minKeepIndex = bar_index - barsBack

// ===== EMA filter =====
emaFast = ta.ema(close, emaFastLen)
emaSlow = ta.ema(close, emaSlowLen)
emaBull = emaFast > emaSlow and close > emaFast
emaBear = emaFast < emaSlow and close < emaFast
passBull = true
passBear = true
if useEMAFilter
    passBull := emaBull
    passBear := emaBear
plot(useEMAFilter ? emaFast : na, "EMA Fast", color=color.new(color.yellow, 0))
plot(useEMAFilter ? emaSlow : na, "EMA Slow", color=color.new(color.orange, 0))

// ===== Pivot detection =====
ph = ta.pivothigh(high, pivotStrength, pivotStrength)
pl = ta.pivotlow(low, pivotStrength, pivotStrength)
pivotBar = bar_index - pivotStrength

// ===== Store pivots for signals =====
var float[] resAll = array.new_float()
var float[] supAll = array.new_float()

if not na(ph)
    array.push(resAll, ph)
if not na(pl)
    array.push(supAll, pl)

if array.size(resAll) > lookbackPivots
    array.shift(resAll)
if array.size(supAll) > lookbackPivots
    array.shift(supAll)

// ===== Drawings storage (NO full redraw) =====
var line[] rLines = array.new_line()
var box[]  rBoxes = array.new_box()
var line[] sLines = array.new_line()
var box[]  sBoxes = array.new_box()

f_trim_drawings() =>
    while array.size(rLines) > maxDrawn
        line.delete(array.shift(rLines))
    while array.size(rBoxes) > maxDrawn
        box.delete(array.shift(rBoxes))
    while array.size(sLines) > maxDrawn
        line.delete(array.shift(sLines))
    while array.size(sBoxes) > maxDrawn
        box.delete(array.shift(sBoxes))

// Add new drawings only when a pivot is confirmed AND pivot is within window
if not na(ph) and pivotBar >= minKeepIndex
    levelR = ph
    zoneR = levelR * (zonePercent / 100.0)
    leftX = pivotBar
    rightX = bar_index + extendRight
    bR = box.new(leftX, levelR - zoneR, rightX, levelR + zoneR, border_color=na, bgcolor=resZoneColor)
    lR = line.new(leftX, levelR, rightX, levelR, color=resLineColor, width=2)
    array.push(rBoxes, bR)
    array.push(rLines, lR)
    f_trim_drawings()

if not na(pl) and pivotBar >= minKeepIndex
    levelS = pl
    zoneS = levelS * (zonePercent / 100.0)
    leftX2 = pivotBar
    rightX2 = bar_index + extendRight
    bS = box.new(leftX2, levelS - zoneS, rightX2, levelS + zoneS, border_color=na, bgcolor=supZoneColor)
    lS = line.new(leftX2, levelS, rightX2, levelS, color=supLineColor, width=2)
    array.push(sBoxes, bS)
    array.push(sLines, lS)
    f_trim_drawings()

// ===== Lock reference price (prevents level jump intrabar) =====
float refPrice = close
if not barstate.isconfirmed
    refPrice := close[1]

// ===== Nearest R above / S below refPrice =====
float rLevel = na
float sLevel = na

if array.size(resAll) > 0
    for i = 0 to array.size(resAll) - 1
        v = array.get(resAll, i)
        if v > refPrice
            if na(rLevel)
                rLevel := v
            else
                rLevel := math.min(rLevel, v)

if array.size(supAll) > 0
    for i = 0 to array.size(supAll) - 1
        v = array.get(supAll, i)
        if v < refPrice
            if na(sLevel)
                sLevel := v
            else
                sLevel := math.max(sLevel, v)

// ===== Zones + buffers =====
float rZone = na
float sZone = na
float retBufR = 0.0
float retBufS = 0.0

if not na(rLevel)
    rZone := rLevel * (zonePercent / 100.0)
    retBufR := rLevel * (returnBufferPct / 100.0)

if not na(sLevel)
    sZone := sLevel * (zonePercent / 100.0)
    retBufS := sLevel * (returnBufferPct / 100.0)

haveR = not na(rLevel) and not na(rZone)
haveS = not na(sLevel) and not na(sZone)

// ===== Candle anatomy (LIVE wick %) =====
rng = high - low
bodyTop = math.max(open, close)
bodyBot = math.min(open, close)
upperW = high - bodyTop
lowerW = bodyBot - low

upperPct = 0.0
lowerPct = 0.0
if rng > 0
    upperPct := upperW / rng
    lowerPct := lowerW / rng

minRange = syminfo.mintick * minRangeTicks
rangeOK = rng >= minRange

// ===== Touch rules =====
touchSup = false
touchRes = false
if haveS
    touchSup := low <= (sLevel + sZone)
if haveR
    touchRes := high >= (rLevel - rZone)

// ===== LIVE wick rejection signals =====
buyLive = rangeOK and touchSup and (lowerPct >= minWickPct) and (upperPct <= maxOppWickPct) and (close >= (sLevel + retBufS)) and passBull
sellLive = rangeOK and touchRes and (upperPct >= minWickPct) and (lowerPct <= maxOppWickPct) and (close <= (rLevel - retBufR)) and passBear

// ===== Show ONLY current label =====
var label liveLabel = na
if barstate.islast
    label.delete(liveLabel)
    if buyLive
        liveLabel := label.new(bar_index, low, "B", style=label.style_label_up, color=color.green, textcolor=color.white, size=size.large)
    else if sellLive
        liveLabel := label.new(bar_index, high, "S", style=label.style_label_down, color=color.red, textcolor=color.white, size=size.large)

alertcondition(buyLive, "LIVE B", "LIVE B (support rejection)")
alertcondition(sellLive, "LIVE S", "LIVE S (resistance rejection)")

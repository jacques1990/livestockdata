//@version=5
indicator("Support & Resistance Levels + Breakout/Rejection Signals", overlay=true, max_lines_count=500, max_boxes_count=500)

// ============================================
// INPUT PARAMETERS
// ============================================
lookback       = input.int(50, "Lookback Period", minval=10, maxval=500)
pivotStrength  = input.int(3, "Pivot Strength", minval=1, maxval=15)
numLevels      = input.int(3, "Number of Levels", minval=1, maxval=8)
zonePercent    = input.float(0.3, "Zone Width %", minval=0.1, maxval=2.0)
extendRight    = input.int(50, "Extend Lines Right", minval=10, maxval=200)

// Signal behavior
confirmBars    = input.int(1, "Confirmation bars (0=immediate, 1=2nd candle, 2=3rd candle)", minval=0, maxval=3)
touchMode      = input.string("Wick OR Close", "Touch rule for rejection", options=["Wick OR Close", "Wick only", "Close only"])

// Candle quality thresholds
minBodyPct     = input.float(0.55, "Min body % of range for breakout/breakdown", minval=0.1, maxval=0.95)
maxSmallWick   = input.float(0.25, "Max wick % of range for clean breakout/breakdown", minval=0.05, maxval=0.60)
minLongWick    = input.float(0.45, "Min wick % of range for rejection", minval=0.10, maxval=0.90)

// Optional filters (your “3+ signals” logic helpers)
useEMAFilter   = input.bool(true, "Filter: EMA trend")
emaFastLen     = input.int(14, "EMA Fast", minval=2, maxval=200)
emaSlowLen     = input.int(20, "EMA Slow", minval=2, maxval=300)

useRSIFilter   = input.bool(false, "Filter: RSI bias")
rsiLen         = input.int(14, "RSI Length", minval=2, maxval=50)

useMACDFilter  = input.bool(false, "Filter: MACD bias")
macdFast       = input.int(12, "MACD Fast", minval=2, maxval=50)
macdSlow       = input.int(26, "MACD Slow", minval=3, maxval=100)
macdSignal     = input.int(9,  "MACD Signal", minval=2, maxval=50)

// Colors
resistanceColor     = input.color(color.new(color.red, 80), "Resistance Zone")
supportColor        = input.color(color.new(color.green, 80), "Support Zone")
resistanceLineColor = input.color(color.red, "Resistance Line")
supportLineColor    = input.color(color.green, "Support Line")

// ============================================
// FIND PIVOT HIGHS AND LOWS
// ============================================
var float[] resistanceLevels = array.new_float()
var float[] supportLevels    = array.new_float()

ph = ta.pivothigh(high, pivotStrength, pivotStrength)
pl = ta.pivotlow(low, pivotStrength, pivotStrength)

if not na(ph)
    array.push(resistanceLevels, ph)
if not na(pl)
    array.push(supportLevels, pl)

if array.size(resistanceLevels) > lookback
    array.shift(resistanceLevels)
if array.size(supportLevels) > lookback
    array.shift(supportLevels)

// ============================================
// GET STRONGEST LEVELS (your original logic)
// ============================================
getTopLevels(levels, abovePrice) =>
    result = array.new_float()

    if array.size(levels) > 0
        levelCounts  = array.new_int()
        uniqueLevels = array.new_float()

        for i = 0 to array.size(levels) - 1
            lvl       = array.get(levels, i)
            threshold = lvl * (zonePercent / 100)

            foundMatch = false
            if array.size(uniqueLevels) > 0
                for j = 0 to array.size(uniqueLevels) - 1
                    existingLvl = array.get(uniqueLevels, j)
                    if math.abs(lvl - existingLvl) <= threshold
                        array.set(levelCounts, j, array.get(levelCounts, j) + 1)
                        foundMatch := true
                        break

            if not foundMatch
                array.push(uniqueLevels, lvl)
                array.push(levelCounts, 1)

        filteredLevels = array.new_float()
        filteredCounts = array.new_int()

        if array.size(uniqueLevels) > 0
            for i = 0 to array.size(uniqueLevels) - 1
                lvl = array.get(uniqueLevels, i)
                if abovePrice
                    if lvl > close
                        array.push(filteredLevels, lvl)
                        array.push(filteredCounts, array.get(levelCounts, i))
                else
                    if lvl < close
                        array.push(filteredLevels, lvl)
                        array.push(filteredCounts, array.get(levelCounts, i))

        if array.size(filteredLevels) > 0
            maxIter = math.min(array.size(filteredLevels), numLevels)
            for i = 0 to maxIter - 1
                maxCount = 0
                maxIndex = i
                for j = i to array.size(filteredCounts) - 1
                    cnt = array.get(filteredCounts, j)
                    if cnt > maxCount
                        maxCount := cnt
                        maxIndex := j

                if maxIndex != i and maxIndex < array.size(filteredLevels)
                    tempLvl   = array.get(filteredLevels, i)
                    tempCount = array.get(filteredCounts, i)
                    array.set(filteredLevels, i, array.get(filteredLevels, maxIndex))
                    array.set(filteredCounts, i, array.get(filteredCounts, maxIndex))
                    array.set(filteredLevels, maxIndex, tempLvl)
                    array.set(filteredCounts, maxIndex, tempCount)

                if i < array.size(filteredLevels)
                    array.push(result, array.get(filteredLevels, i))

    result

topResistance = getTopLevels(resistanceLevels, true)
topSupport    = getTopLevels(supportLevels, false)

// ============================================
// NEAREST LEVEL HELPERS (for signals)
// ============================================
getNearestAbove(levelsArr) =>
    float best = na
    if array.size(levelsArr) > 0
        for i = 0 to array.size(levelsArr) - 1
            lvl = array.get(levelsArr, i)
            if lvl > close
                best := na(best) ? lvl : math.min(best, lvl)
    best

getNearestBelow(levelsArr) =>
    float best = na
    if array.size(levelsArr) > 0
        for i = 0 to array.size(levelsArr) - 1
            lvl = array.get(levelsArr, i)
            if lvl < close
                best := na(best) ? lvl : math.max(best, lvl)
    best

rLevel = getNearestAbove(topResistance)
sLevel = getNearestBelow(topSupport)

rZone = not na(rLevel) ? rLevel * (zonePercent / 100) : na
sZone = not na(sLevel) ? sLevel * (zonePercent / 100) : na

// ============================================
// CANDLE STATS (wick/body logic)
// ============================================
rng   = high - low
body  = math.abs(close - open)
upper = high - math.max(open, close)
lower = math.min(open, close) - low

bodyPct  = rng > 0 ? body / rng : 0.0
upperPct = rng > 0 ? upper / rng : 0.0
lowerPct = rng > 0 ? lower / rng : 0.0

cleanBull = bodyPct >= minBodyPct and upperPct <= maxSmallWick
cleanBear = bodyPct >= minBodyPct and lowerPct <= maxSmallWick

rejAtRes  = upperPct >= minLongWick
rejAtSup  = lowerPct >= minLongWick

// Touch logic for rejection
touchRes =
     not na(rLevel) and (
        touchMode == "Wick OR Close" ? (high >= (rLevel - rZone) or close >= (rLevel - rZone)) :
        touchMode == "Wick only"     ? (high >= (rLevel - rZone)) :
                                       (close >= (rLevel - rZone))
     )

touchSup =
     not na(sLevel) and (
        touchMode == "Wick OR Close" ? (low <= (sLevel + sZone) or close <= (sLevel + sZone)) :
        touchMode == "Wick only"     ? (low <= (sLevel + sZone)) :
                                       (close <= (sLevel + sZone))
     )

// ============================================
// OPTIONAL FILTERS (EMA / RSI / MACD)
// ============================================
emaFast = ta.ema(close, emaFastLen)
emaSlow = ta.ema(close, emaSlowLen)
emaBull = emaFast > emaSlow and close > emaFast
emaBear = emaFast < emaSlow and close < emaFast

rsiVal  = ta.rsi(close, rsiLen)
rsiBull = rsiVal > 50
rsiBear = rsiVal < 50

[macdLine, sigLine, hist] = ta.macd(close, macdFast, macdSlow, macdSignal)
macdBull = macdLine > sigLine and hist >= 0
macdBear = macdLine < sigLine and hist <= 0

passBullFilters = (not useEMAFilter or emaBull) and (not useRSIFilter or rsiBull) and (not useMACDFilter or macdBull)
passBearFilters = (not useEMAFilter or emaBear) and (not useRSIFilter or rsiBear) and (not useMACDFilter or macdBear)

// ============================================
// BREAKOUT / BREAKDOWN + CONFIRMATION
// ============================================
// "Breakout now" means CLOSE beyond zone boundary
breakAbove = not na(rLevel) and close > (rLevel + rZone)
breakBelow = not na(sLevel) and close < (sLevel - sZone)

// Confirmation: wait N bars that remain beyond the level
heldAbove = confirmBars == 0 ? breakAbove : (breakAbove and ta.barssince(not breakAbove) >= confirmBars)
heldBelow = confirmBars == 0 ? breakBelow : (breakBelow and ta.barssince(not breakBelow) >= confirmBars)

// ============================================
// SIGNALS
// ============================================
// 1) Breakout BUY (clean bullish candle, held above, filters)
buyBreakout  = heldAbove and cleanBull and passBullFilters

// 2) Breakdown SHORT (clean bearish candle, held below, filters)
shortBreakdown = heldBelow and cleanBear and passBearFilters

// 3) Resistance rejection SHORT (touch res, long upper wick, close back below line)
shortRejection = touchRes and rejAtRes and not na(rLevel) and close < rLevel and passBearFilters

// 4) Support rejection BUY (touch sup, long lower wick, close back above line)
buyRejection = touchSup and rejAtSup and not na(sLevel) and close > sLevel and passBullFilters

// ============================================
// PLOTS (Signals)
// ============================================
plotshape(buyBreakout, title="BUY Breakout", style=shape.labelup, text="BUY\nBO", location=location.belowbar, size=size.tiny, color=color.new(color.green, 0), textcolor=color.white)
plotshape(shortBreakdown, title="SHORT Breakdown", style=shape.labeldown, text="SELL\nBD", location=location.abovebar, size=size.tiny, color=color.new(color.red, 0), textcolor=color.white)

plotshape(buyRejection, title="BUY Rejection @ Support", style=shape.triangleup, text="BUY\nRJ", location=location.belowbar, size=size.tiny, color=color.new(color.lime, 0), textcolor=color.black)
plotshape(shortRejection, title="SHORT Rejection @ Resistance", style=shape.triangledown, text="SELL\nRJ", location=location.abovebar, size=size.tiny, color=color.new(color.maroon, 0), textcolor=color.white)

// Optional: show EMAs if using filter
plot(useEMAFilter ? emaFast : na, "EMA Fast", color=color.new(color.yellow, 0))
plot(useEMAFilter ? emaSlow : na, "EMA Slow", color=color.new(color.orange, 0))

// ============================================
// DRAW LEVELS (your original drawing, last-bar only)
// ============================================
var line[] rLines = array.new_line()
var box[]  rBoxes = array.new_box()
var line[] sLines = array.new_line()
var box[]  sBoxes = array.new_box()

if barstate.islast
    if array.size(rLines) > 0
        for l in rLines
            line.delete(l)
    if array.size(rBoxes) > 0
        for b in rBoxes
            box.delete(b)
    if array.size(sLines) > 0
        for l in sLines
            line.delete(l)
    if array.size(sBoxes) > 0
        for b in sBoxes
            box.delete(b)

    array.clear(rLines), array.clear(rBoxes), array.clear(sLines), array.clear(sBoxes)

    if array.size(topResistance) > 0
        for i = 0 to array.size(topResistance) - 1
            level = array.get(topResistance, i)
            zone  = level * (zonePercent / 100)

            b = box.new(bar_index - lookback, level - zone, bar_index + extendRight, level + zone, border_color=na, bgcolor=resistanceColor)
            array.push(rBoxes, b)

            l = line.new(bar_index - lookback, level, bar_index + extendRight, level, color=resistanceLineColor, width=2)
            array.push(rLines, l)

    if array.size(topSupport) > 0
        for i = 0 to array.size(topSupport) - 1
            level = array.get(topSupport, i)
            zone  = level * (zonePercent / 100)

            b = box.new(bar_index - lookback, level - zone, bar_index + extendRight, level + zone, border_color=na, bgcolor=supportColor)
            array.push(sBoxes, b)

            l = line.new(bar_index - lookback, level, bar_index + extendRight, level, color=supportLineColor, width=2)
            array.push(sLines, l)

// ============================================
// INFO LABEL
// ============================================
if barstate.islast
    var label info = na
    label.delete(info)
    txt = "R:" + str.tostring(array.size(topResistance)) + " S:" + str.tostring(array.size(topSupport)) +
          "\nNearest R: " + (na(rLevel) ? "na" : str.tostring(rLevel)) +
          "\nNearest S: " + (na(sLevel) ? "na" : str.tostring(sLevel))
    info := label.new(bar_index, high, txt, style=label.style_label_down, color=color.new(color.gray, 70), textcolor=color.white, size=size.small)
